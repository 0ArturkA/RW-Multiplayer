using Harmony;
using Multiplayer.Common;
using RimWorld;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Threading;
using UnityEngine;
using Verse;
using Verse.AI;
using Verse.Sound;
using static Verse.ImmunityHandler;
using static Verse.LongEventHandler;
using static Verse.RegionTraverser;

namespace Multiplayer.Client
{
    public static class ThreadStatics
    {
        // AUTOGENERATED

        [ThreadStatic]
        [Source(typeof(ThinkNode_PrioritySorter), nameof(ThinkNode_PrioritySorter.workingNodes))]
        [UsedBy(typeof(ThinkNode_PrioritySorter), nameof(ThinkNode_PrioritySorter.TryIssueJobPackage))]
        public static List<ThinkNode> workingNodes = new List<ThinkNode>();

        [ThreadStatic]
        [Source(typeof(BeautyUtility), nameof(BeautyUtility.tempCountedThings))]
        [UsedBy(typeof(BeautyUtility), nameof(BeautyUtility.AverageBeautyPerceptible))]
        public static List<Thing> tempCountedThings = new List<Thing>();

        /*[ThreadStatic]
        [Source(typeof(RegionTraverser), nameof(RegionTraverser.freeWorkers))]
        [UsedBy(typeof(RegionTraverser), nameof(RegionTraverser.RecreateWorkers))]
        [UsedBy(typeof(RegionTraverser), nameof(RegionTraverser.BreadthFirstTraverse), new[] { typeof(Region), typeof(RegionEntryPredicate), typeof(RegionProcessor), typeof(int), typeof(RegionType) })]
        public static Queue<BFSWorker> freeWorkers = new Queue<BFSWorker>();*/

        [ThreadStatic]
        [Source(typeof(ImmunityHandler), nameof(ImmunityHandler.tmpNeededImmunitiesNow))]
        [UsedBy(typeof(ImmunityHandler), nameof(ImmunityHandler.NeededImmunitiesNow))]
        public static List<ImmunityInfo> tmpNeededImmunitiesNow = new List<ImmunityInfo>();

        [ThreadStatic]
        [Source(typeof(WildPlantSpawner), nameof(WildPlantSpawner.tmpPlantDefsLowerOrder))]
        [UsedBy(typeof(WildPlantSpawner), nameof(WildPlantSpawner.EnoughLowerOrderPlantsNearby))]
        [UsedBy(typeof(WildPlantSpawner), "<EnoughLowerOrderPlantsNearby>c__AnonStorey1", "<>m__1")]
        public static List<ThingDef> tmpPlantDefsLowerOrder = new List<ThingDef>();

        [ThreadStatic]
        [Source(typeof(BeautyUtility), nameof(BeautyUtility.visibleRooms))]
        [UsedBy(typeof(BeautyUtility), nameof(BeautyUtility.FillBeautyRelevantCells))]
        public static List<Room> visibleRooms = new List<Room>();

        [ThreadStatic]
        [Source(typeof(RegionListersUpdater), nameof(RegionListersUpdater.tmpRegions))]
        [UsedBy(typeof(RegionListersUpdater), nameof(RegionListersUpdater.DeregisterInRegions))]
        [UsedBy(typeof(RegionListersUpdater), nameof(RegionListersUpdater.RegisterInRegions))]
        public static List<Region> tmpRegions = new List<Region>();

        [ThreadStatic]
        [Source(typeof(ThoughtHandler), nameof(ThoughtHandler.tmpTotalMoodOffsetThoughts))]
        [UsedBy(typeof(ThoughtHandler), nameof(ThoughtHandler.TotalMoodOffset))]
        public static List<Thought> tmpTotalMoodOffsetThoughts = new List<Thought>();

        [ThreadStatic]
        [Source(typeof(ThoughtHandler), nameof(ThoughtHandler.tmpThoughts))]
        [UsedBy(typeof(ThoughtHandler), nameof(ThoughtHandler.MoodOffsetOfGroup))]
        public static List<Thought> tmpThoughts = new List<Thought>();

        [ThreadStatic]
        [Source(typeof(ThoughtHandler), nameof(ThoughtHandler.tmpSocialThoughts))]
        [UsedBy(typeof(ThoughtHandler), nameof(ThoughtHandler.OpinionOffsetOfGroup))]
        public static List<ISocialThought> tmpSocialThoughts = new List<ISocialThought>();

        [ThreadStatic]
        [Source(typeof(ThoughtHandler), nameof(ThoughtHandler.tmpTotalOpinionOffsetThoughts))]
        [UsedBy(typeof(ThoughtHandler), nameof(ThoughtHandler.TotalOpinionOffset))]
        public static List<ISocialThought> tmpTotalOpinionOffsetThoughts = new List<ISocialThought>();

        [ThreadStatic]
        [Source(typeof(PowerNet), nameof(PowerNet.partsWantingPowerOn))]
        [UsedBy(typeof(PowerNet), nameof(PowerNet.PowerNetTick))]
        public static List<CompPowerTrader> partsWantingPowerOn = new List<CompPowerTrader>();

        [ThreadStatic]
        [Source(typeof(PowerNet), nameof(PowerNet.potentialShutdownParts))]
        [UsedBy(typeof(PowerNet), nameof(PowerNet.PowerNetTick))]
        public static List<CompPowerTrader> potentialShutdownParts = new List<CompPowerTrader>();

        [ThreadStatic]
        [Source(typeof(PowerNet), nameof(PowerNet.batteriesShuffled))]
        [UsedBy(typeof(PowerNet), nameof(PowerNet.DistributeEnergyAmongBatteries))]
        public static List<CompPowerBattery> batteriesShuffled = new List<CompPowerBattery>();

        [ThreadStatic]
        [Source(typeof(Rand), nameof(Rand.random))]
        [UsedBy(typeof(Rand), nameof(Rand.Seed), PropertyMethod.Setter)]
        [UsedBy(typeof(Rand), nameof(Rand.Value), PropertyMethod.Getter)]
        [UsedBy(typeof(Rand), nameof(Rand.Int), PropertyMethod.Getter)]
        [UsedBy(typeof(Rand), nameof(Rand.StateCompressed), PropertyMethod.Getter)]
        [UsedBy(typeof(Rand), nameof(Rand.StateCompressed), PropertyMethod.Setter)]
        public static RandomNumberGenerator random = new RandomNumberGenerator_BasicHash();

        [ThreadStatic]
        [Source(typeof(Rand), nameof(Rand.iterations))]
        [UsedBy(typeof(Rand), nameof(Rand.Seed), PropertyMethod.Setter)]
        [UsedBy(typeof(Rand), nameof(Rand.Value), PropertyMethod.Getter)]
        [UsedBy(typeof(Rand), nameof(Rand.Int), PropertyMethod.Getter)]
        [UsedBy(typeof(Rand), nameof(Rand.StateCompressed), PropertyMethod.Getter)]
        [UsedBy(typeof(Rand), nameof(Rand.StateCompressed), PropertyMethod.Setter)]
        public static uint iterations = 0;

        [ThreadStatic]
        [Source(typeof(Pawn_InteractionsTracker), nameof(Pawn_InteractionsTracker.workingList))]
        [UsedBy(typeof(Pawn_InteractionsTracker), nameof(Pawn_InteractionsTracker.TryInteractRandomly))]
        public static List<Pawn> workingList = new List<Pawn>();

        [ThreadStatic]
        [Source(typeof(CameraDriver), nameof(CameraDriver.lastViewRectGetFrame))]
        [UsedBy(typeof(CameraDriver), nameof(CameraDriver.CurrentViewRect), PropertyMethod.Getter)]
        public static int lastViewRectGetFrame = -1;

        [ThreadStatic]
        [Source(typeof(CameraDriver), nameof(CameraDriver.lastViewRect))]
        [UsedBy(typeof(CameraDriver), nameof(CameraDriver.CurrentViewRect), PropertyMethod.Getter)]
        public static CellRect lastViewRect;

        [ThreadStatic]
        [Source(typeof(HaulAIUtility), nameof(HaulAIUtility.candidates))]
        [UsedBy(typeof(HaulAIUtility), "<TryFindSpotToPlaceHaulableCloseTo>c__AnonStorey0", "<>m__1")]
        public static List<IntVec3> candidates = new List<IntVec3>();

        [ThreadStatic]
        [Source(typeof(Rand), nameof(Rand.stateStack))]
        [UsedBy(typeof(Rand), nameof(Rand.Seed), PropertyMethod.Setter)]
        [UsedBy(typeof(Rand), nameof(Rand.EnsureStateStackEmpty))]
        [UsedBy(typeof(Rand), nameof(Rand.PushState), new Type[0])]
        [UsedBy(typeof(Rand), nameof(Rand.PopState))]
        public static Stack<ulong> stateStack = new Stack<ulong>();

        [ThreadStatic]
        [Source(typeof(RCellFinder), nameof(RCellFinder.tmpBuildings))]
        [UsedBy(typeof(RCellFinder), "<TryFindRandomSpotJustOutsideColony>c__AnonStorey9", "<>m__0")]
        public static HashSet<Thing> tmpBuildings = new HashSet<Thing>();

        [ThreadStatic]
        [Source(typeof(CellFinder), nameof(CellFinder.workingCells))]
        [UsedBy(typeof(CellFinder), nameof(CellFinder.TryFindRandomCellInRegion))]
        public static List<IntVec3> workingCells = new List<IntVec3>();

        [ThreadStatic]
        [Source(typeof(Pawn_WorkSettings), nameof(Pawn_WorkSettings.wtsByPrio))]
        [UsedBy(typeof(Pawn_WorkSettings), nameof(Pawn_WorkSettings.CacheWorkGiversInOrder))]
        public static List<WorkTypeDef> wtsByPrio = new List<WorkTypeDef>();

        [ThreadStatic]
        [Source(typeof(WorkGiver_DoBill), nameof(WorkGiver_DoBill.processedThings))]
        [UsedBy(typeof(WorkGiver_DoBill), nameof(WorkGiver_DoBill.TryFindBestBillIngredients))]
        [UsedBy(typeof(WorkGiver_DoBill), "<TryFindBestBillIngredients>c__AnonStorey1", "<>m__3")]
        public static HashSet<Thing> processedThings = new HashSet<Thing>();

        [ThreadStatic]
        [Source(typeof(WorkGiver_DoBill), nameof(WorkGiver_DoBill.newRelevantThings))]
        [UsedBy(typeof(WorkGiver_DoBill), nameof(WorkGiver_DoBill.TryFindBestBillIngredients))]
        [UsedBy(typeof(WorkGiver_DoBill), "<TryFindBestBillIngredients>c__AnonStorey1", "<>m__3")]
        public static List<Thing> newRelevantThings = new List<Thing>();

        [ThreadStatic]
        [Source(typeof(WorkGiver_DoBill), nameof(WorkGiver_DoBill.relevantThings))]
        [UsedBy(typeof(WorkGiver_DoBill), nameof(WorkGiver_DoBill.TryFindBestBillIngredients))]
        [UsedBy(typeof(WorkGiver_DoBill), "<TryFindBestBillIngredients>c__AnonStorey1", "<>m__3")]
        public static List<Thing> relevantThings = new List<Thing>();

        [ThreadStatic]
        [Source(typeof(WorkGiver_DoBill), nameof(WorkGiver_DoBill.ingredientsOrdered))]
        [UsedBy(typeof(WorkGiver_DoBill), nameof(WorkGiver_DoBill.TryFindBestBillIngredients))]
        [UsedBy(typeof(WorkGiver_DoBill), nameof(WorkGiver_DoBill.TryFindBestBillIngredientsInSet_NoMix))]
        public static List<IngredientCount> ingredientsOrdered = new List<IngredientCount>();

        [ThreadStatic]
        [Source(typeof(IncidentCycleUtility), nameof(IncidentCycleUtility.hits))]
        [UsedBy(typeof(IncidentCycleUtility), nameof(IncidentCycleUtility.IncidentCountThisInterval))]
        [UsedBy(typeof(IncidentCycleUtility), nameof(IncidentCycleUtility.GenerateHitList))]
        public static List<int> hits = new List<int>();

        [ThreadStatic]
        [Source(typeof(Need_RoomSize), nameof(Need_RoomSize.tempScanRooms))]
        [UsedBy(typeof(Need_RoomSize), nameof(Need_RoomSize.SpacePerceptibleNow))]
        public static List<Room> tempScanRooms = new List<Room>();

        [ThreadStatic]
        [Source(typeof(GenTemperature), nameof(GenTemperature.neighRoomGroups))]
        [UsedBy(typeof(GenTemperature), nameof(GenTemperature.PushHeat), new[] { typeof(IntVec3), typeof(Map), typeof(float) })]
        public static List<RoomGroup> neighRoomGroups = new List<RoomGroup>();

        [ThreadStatic]
        [Source(typeof(Toils_Ingest), nameof(Toils_Ingest.spotSearchList))]
        [UsedBy(typeof(Toils_Ingest), nameof(Toils_Ingest.TryFindAdjacentIngestionPlaceSpot))]
        public static List<IntVec3> spotSearchList = new List<IntVec3>();

        [ThreadStatic]
        [Source(typeof(TendUtility), nameof(TendUtility.tmpHediffs))]
        [UsedBy(typeof(TendUtility), nameof(TendUtility.GetOptimalHediffsToTendWithSingleTreatment))]
        public static List<Hediff> tmpHediffs = new List<Hediff>();

        [ThreadStatic]
        [Source(typeof(WildPlantSpawner), nameof(WildPlantSpawner.tmpPossiblePlants))]
        [UsedBy(typeof(WildPlantSpawner), nameof(WildPlantSpawner.CheckSpawnWildPlantAt))]
        public static List<ThingDef> tmpPossiblePlants = new List<ThingDef>();

        [ThreadStatic]
        [Source(typeof(WildPlantSpawner), nameof(WildPlantSpawner.tmpPossiblePlantsWithWeight))]
        [UsedBy(typeof(WildPlantSpawner), nameof(WildPlantSpawner.CheckSpawnWildPlantAt))]
        public static List<KeyValuePair<ThingDef, float>> tmpPossiblePlantsWithWeight = new List<KeyValuePair<ThingDef, float>>();

        [ThreadStatic]
        [Source(typeof(WildPlantSpawner), nameof(WildPlantSpawner.distanceSqToNearbyClusters))]
        [UsedBy(typeof(WildPlantSpawner), nameof(WildPlantSpawner.CheckSpawnWildPlantAt))]
        [UsedBy(typeof(WildPlantSpawner), nameof(WildPlantSpawner.CalculateDistancesToNearbyClusters))]
        public static Dictionary<ThingDef, float> distanceSqToNearbyClusters = new Dictionary<ThingDef, float>();

        [ThreadStatic]
        [Source(typeof(FoodUtility), nameof(FoodUtility.filtered))]
        [UsedBy(typeof(FoodUtility), nameof(FoodUtility.BestFoodSourceOnMap))]
        [UsedBy(typeof(FoodUtility), "<BestFoodSourceOnMap>c__AnonStorey0", "<>m__2")]
        public static HashSet<Thing> filtered = new HashSet<Thing>();

        [ThreadStatic]
        [Source(typeof(FoodUtility), nameof(FoodUtility.ingestThoughts))]
        [UsedBy(typeof(FoodUtility), nameof(FoodUtility.ThoughtsFromIngesting))]
        public static List<ThoughtDef> ingestThoughts = new List<ThoughtDef>();

        [ThreadStatic]
        [Source(typeof(CellFinder), nameof(CellFinder.workingRegions))]
        [UsedBy(typeof(CellFinder), nameof(CellFinder.RandomRegionNear))]
        [UsedBy(typeof(CellFinder), nameof(CellFinder.TryFindRandomReachableCellNear))]
        [UsedBy(typeof(CellFinder), "<RandomRegionNear>m__0")]
        [UsedBy(typeof(CellFinder), "<TryFindRandomReachableCellNear>m__2")]
        public static List<Region> workingRegions = new List<Region>();

        [ThreadStatic]
        [Source(typeof(Zone), nameof(Zone.foundGrid))]
        [UsedBy(typeof(Zone), nameof(Zone.CheckContiguous))]
        [UsedBy(typeof(Zone), "<CheckContiguous>m__0")]
        [UsedBy(typeof(Zone), "<CheckContiguous>c__AnonStorey5", "<>m__0")]
        public static BoolGrid foundGrid;

        [ThreadStatic]
        [Source(typeof(Toils_JobTransforms), nameof(Toils_JobTransforms.yieldedIngPlaceCells))]
        [UsedBy(typeof(Toils_JobTransforms), "<IngredientPlaceCellsInOrder>c__Iterator0", "MoveNext")]
        [UsedBy(typeof(Toils_JobTransforms), "<IngredientPlaceCellsInOrder>c__Iterator0", "<>__Finally0")]
        public static List<IntVec3> yieldedIngPlaceCells = new List<IntVec3>();

        // END AUTOGENERATED

        [ThreadStatic]
        [Source(typeof(Toils_Ingest), nameof(Toils_Ingest.cardinals))]
        [UsedBy(typeof(Toils_Ingest), nameof(Toils_Ingest.TryFindAdjacentIngestionPlaceSpot))]
        public static List<IntVec3> cardinals = GenAdj.CardinalDirections.ToList();

        [ThreadStatic]
        [Source(typeof(Toils_Ingest), nameof(Toils_Ingest.diagonals))]
        [UsedBy(typeof(Toils_Ingest), nameof(Toils_Ingest.TryFindAdjacentIngestionPlaceSpot))]
        public static List<IntVec3> diagonals = GenAdj.DiagonalDirections.ToList();

        [ThreadStatic]
        public static Stack<Faction> factionContextStack = new Stack<Faction>();

        [ThreadStatic]
        public static Stack<Pair<Thing, Map>> thingContextStack = new Stack<Pair<Thing, Map>>()
        {
            new Pair<Thing, Map>(null, null)
        };

        static ThreadStatics()
        {
            //RecreateWorkers();
        }
    }

    public static class ThreadStaticsData
    {
        private static Dictionary<MethodInfo, List<FieldInfo>> usedFields = new Dictionary<MethodInfo, List<FieldInfo>>();
        private static Dictionary<FieldInfo, FieldInfo> replacements = new Dictionary<FieldInfo, FieldInfo>();

        public static void RegisterAll()
        {
            foreach (FieldInfo field in typeof(ThreadStatics).GetFields())
            {
                if (!field.TryGetAttribute(out SourceAttribute sourceAttr)) continue;

                FieldInfo original = AccessTools.Field(sourceAttr.type, sourceAttr.field);
                replacements[original] = field;

                foreach (UsedByAttribute attr in field.AllAttributes<UsedByAttribute>())
                {
                    MethodInfo method;
                    if (attr.args != null)
                        method = attr.type.GetMethod(attr.method, AccessTools.all, null, attr.args, null);
                    else
                        method = attr.type.GetMethod(attr.method, AccessTools.all);

                    usedFields.GetOrAddNew(method).Add(original);
                }
            }
        }

        public static void Patch()
        {
            HarmonyInstance harmony = Multiplayer.harmony;

            harmony.DoMpPatches(typeof(MakeMotePatch2));
            harmony.DoMpPatches(typeof(MotesPatch));
            harmony.DoMpPatches(typeof(BFSWorkerLock));

            HarmonyMethod transpiler = new HarmonyMethod(typeof(ThreadStaticsData), nameof(ThreadStaticsData.Transpiler));
            foreach (MethodInfo method in usedFields.Keys)
                harmony.Patch(method, null, null, transpiler);
        }

        static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> insts, MethodBase original)
        {
            foreach (CodeInstruction inst in insts)
            {
                if (inst.opcode == OpCodes.Ldsfld || inst.opcode == OpCodes.Stsfld || inst.opcode == OpCodes.Ldsflda)
                {
                    FieldInfo field = (FieldInfo)inst.operand;
                    if (replacements.TryGetValue(field, out FieldInfo replacement))
                        inst.operand = replacement;
                }

                yield return inst;
            }
        }

        public static void InvokeCctor()
        {
            typeof(ThreadStatics).TypeInitializer.Invoke(null, null);
        }
    }

    [HarmonyPatch(typeof(LongEventHandler), nameof(LongEventHandler.RunEventFromAnotherThread))]
    static class RunFromAnotherThreadPatch
    {
        static void Prefix()
        {
            ThreadStaticsData.InvokeCctor();
        }
    }

    [HarmonyPatch(typeof(LongEventHandler), nameof(LongEventHandler.ExecuteWhenFinished))]
    static class LockExecuteWhenFinished
    {
        private static object lockObj = new object();

        static void Prefix(ref bool __state)
        {
            Monitor.Enter(lockObj);
            __state = true;
        }

        static void Postfix(bool __state)
        {
            if (__state)
                Monitor.Exit(lockObj);
        }
    }

    [MpPatch(typeof(SoundStarter), nameof(SoundStarter.TrySpawnSustainer))]
    [MpPatch(typeof(MoteMaker), nameof(MoteMaker.MakeInteractionBubble))]
    [MpPatch(typeof(MoteMaker), nameof(MoteMaker.MakeMoodThoughtBubble))]
    static class MakeMotePatch2
    {
        static bool Prefix() => UnityData.IsInMainThread;
    }

    [MpPatch(typeof(RealtimeMoteList), nameof(RealtimeMoteList.Clear))]
    [MpPatch(typeof(RealtimeMoteList), nameof(RealtimeMoteList.MoteSpawned))]
    [MpPatch(typeof(RealtimeMoteList), nameof(RealtimeMoteList.MoteDespawned))]
    static class MotesPatch
    {
        private static object lockObj = new object();

        static void Prefix(ref bool __state)
        {
            Monitor.Enter(lockObj);
            __state = true;
        }

        static void Postfix(bool __state)
        {
            if (__state)
                Monitor.Exit(lockObj);
        }
    }

    [HarmonyPatch(typeof(InteractionDef))]
    [HarmonyPatch(nameof(InteractionDef.Symbol), PropertyMethod.Getter)]
    static class MakeMotePatch3
    {
        static bool Prefix() => UnityData.IsInMainThread;
    }

    [MpPatch(typeof(RegionTraverser), nameof(RegionTraverser.BreadthFirstTraverse), new[] { typeof(Region), typeof(RegionEntryPredicate), typeof(RegionProcessor), typeof(int), typeof(RegionType) })]
    static class BFSWorkerLock
    {
        private static object lockObj = new object();

        static void Prefix(ref bool __state)
        {
            Monitor.Enter(lockObj);
            __state = true;
        }

        static void Postfix(bool __state)
        {
            if (__state)
                Monitor.Exit(lockObj);
        }
    }

    [AttributeUsage(AttributeTargets.Field)]
    class SourceAttribute : Attribute
    {
        public readonly Type type;
        public readonly string field;

        public SourceAttribute(Type type, string field)
        {
            this.type = type;
            this.field = field;
        }
    }

    [AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
    class UsedByAttribute : Attribute
    {
        public readonly Type type;
        public readonly string method;
        public readonly Type[] args;

        public UsedByAttribute(Type type, string method, Type[] args = null)
        {
            this.type = type;
            this.method = method;
            this.args = args;
        }

        public UsedByAttribute(Type type, string innerType, string method, Type[] args = null) :
            this(type.GetNestedTypes(AccessTools.all).First(m => m.Name == innerType), method, args)
        {
        }

        public UsedByAttribute(Type type, string property, PropertyMethod propertyMethod)
        {
            this.type = type;
            this.method = (propertyMethod == PropertyMethod.Getter ? "get_" : "set_") + property;
        }
    }
}
